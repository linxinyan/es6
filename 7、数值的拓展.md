## 一、二进制和八进制表示法
分别用前缀0b（或0B）和0o（或0O）表示二进制和八进制。<br>
如果要将0b和0o前缀的字符串数值转为十进制，要使用Number方法。

    Number('0b111')  // 7
    Number('0o10')  // 8
## 二、Number.isFinite(), Number.isNaN() 
Number.isFinite()用来检查一个数值是否为有限的（finite）。如果参数类型不是数值，Number.isFinite一律返回false<br>
Number.isNaN()用来检查一个值是否为NaN。如果参数类型不是NaN，Number.isNaN一律返回false

    Number.isNaN(NaN) // true
    Number.isNaN('NaN') // false
    Number.isNaN(true) // false
    Number.isNaN(9/NaN) // true
    Number.isNaN('true' / 0) // true
    Number.isNaN('true' / 'true') // true
* 与传统的全局方法isFinite()和isNaN()的区别在于，传统方法先调用Number()将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效 <br>
isNaN —— 检查值是否不是一个普通数字或者是否不能转换为一个普通数字。<br>
Number.isNaN —— 检查值是否为 NaN。<br>

    isFinite(25) // true
    isFinite("25") // true
    Number.isFinite(25) // true
    Number.isFinite("25") // false

    isNaN(NaN) // true
    isNaN("NaN") // true
    Number.isNaN(NaN) // true
    Number.isNaN("NaN") // false
## 三、Number.parseInt(), Number.parseFloat()
将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变。这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。
## 四、Number.isInteger()
用来判断一个数值是否为整数。<br>
* JavaScript 内部，整数和浮点数采用的是同样的储存方法，故如 25 和 25.0 被视为同一个值。<br>
* 如果数值的精度超过或低于一定限度，Number.isInteger可能会误判。所以如果对数据精度的要求较高，不建议使用Number.isInteger()判断一个数值是否为整数。
## 五、Number.EPSILON
是 JavaScript 能够表示的最小精度。等于 2 的 -52 次方。误差如果小于这个值，就可以认为已经没有意义了，即不存在误差了。<br>
引入一个这么小的量的目的，在于为浮点数计算，设置一个误差范围。我们知道浮点数计算是不精确的。<br>
如误差范围设为 2 的-50 次方（即Number.EPSILON * Math.pow(2, 2)）

    function withinErrorMargin (left, right) {
        return Math.abs(left - right) < Number.EPSILON * Math.pow(2, 2);
    }
    
    0.1 + 0.2 === 0.3 // false
    withinErrorMargin(0.1 + 0.2, 0.3) // true






